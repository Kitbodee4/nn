from loguru import logger
import pandas as pd

# Configure loguru
logger.remove()
logger.add("structure_mapping.log", rotation="1 MB", format="{time} | {level} | {message}")
logger.add("structure_mapping_debug.log", rotation="1 MB", format="{time} | {message}")

# Global variables
structArr = []
structTimeArr = []
structPriceArr = []
structBarArr = []
obArray = []
lookback = 4

# Input parameters
equalHL = False
showHL = True
showMn = False
showBC = True
showIDM = False
showliveIDM = True
showSw = False
markX = False

# Initialize state variables
mnUp = None
mnDn = None
top = None
bot = None
puUp = None
puDn = None
L = None
H = None
idmB = None
idmS = None
lastH = None
lastL = None
lastHH = None
lastLL = None
puUp_time = None
puDn_time = None
idmB_time = None
idmS_time = None
H_time = None
L_time = None
lastH_time = None
lastL_time = None
lastHH_time = None
lastLL_time = None
isBosUp = False
isBosDn = False
isCocUp = True
isCocDn = True
df = None  # Global DataFrame
lll=0
chk_l=False
countu=0
con1=False
isMajor=False
waitingForHL=False
# Utility functions
def is_na(value):
    return value is None

def f_get50PctLine(priceA, priceB):
    return (priceA + priceB) / 2.0

# OBData class
class OBData:
    def __init__(self, bar_time, topPrice, bottomPrice, isMajorUp):
        self.bar_time = bar_time
        self.topPrice = topPrice
        self.bottomPrice = bottomPrice
        self.isMajorUp = isMajorUp

# Load data from CSV
def load_ohlcv(file_path="15m.csv"):
    try:
        df = pd.read_csv(file_path, usecols=['open_time', 'open', 'high', 'low', 'close', 'volume'])
        df = df.rename(columns={'open_time': 'timestamp'})
        required_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
        if not all(col in df.columns for col in required_columns):
            missing_cols = [col for col in required_columns if col not in df.columns]
            logger.error(f"Missing required columns: {missing_cols}")
            raise ValueError(f"CSV must contain columns: {required_columns}")
        try:
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        except ValueError:
            try:
                df['timestamp'] = pd.to_datetime(df['timestamp'])
            except ValueError as e:
                logger.error(f"Failed to parse timestamp column: {e}")
                raise ValueError("Timestamp column must be in a valid datetime format")
        if df[required_columns].isnull().any().any():
            logger.warning("CSV contains missing values; dropping rows with NaN")
            df = df.dropna(subset=required_columns)
        df = df.reset_index(drop=True)
        time_diff = df['timestamp'].diff().dropna()
        expected_diff = pd.Timedelta(minutes=15)
        if not (time_diff == expected_diff).all():
            logger.warning("Data contains gaps or irregular timestamps")
        logger.info(f"Successfully loaded {len(df)} 15-minute bars from {file_path}")
        return df
    except FileNotFoundError:
        logger.error(f"CSV file not found: {file_path}")
        raise
    except pd.errors.ParserError:
        logger.error(f"Failed to parse CSV file: {file_path}")
        raise
    except Exception as e:
        logger.error(f"Error loading CSV file: {e}")
        raise

# Helper functions
def f_loginfo(message):
    logger.info(message)

def f_storeOB(isMajorUp, topPrice, bottomPrice, current_time=None):
    newOB = OBData(
        bar_time=current_time if current_time is not None else 0,
        topPrice=topPrice,
        bottomPrice=bottomPrice,
        isMajorUp=isMajorUp
    )
    obArray.insert(0, newOB)
    log_text = f"f_storeOB -> {'Bullish' if isMajorUp else 'Bearish'} top={topPrice} bottom={bottomPrice}"
    f_loginfo(log_text)
    return [isMajorUp, bottomPrice, topPrice]

def f_findFirstHigherHigh(currentHigh, lookback_in, refBar, df):
    firstHigherHigh = None
    firstbarH = None
    for i in range(1, lookback_in + 1):
        checkBar = refBar - i
        if checkBar >= 0 and checkBar < len(df):
            histHigh = df.loc[checkBar, 'high']
            if histHigh > currentHigh:
                firstHigherHigh = histHigh
                firstbarH = checkBar
                break
    return [firstHigherHigh, firstbarH]

def f_findFirstLowerLow(currentLow, lookback_in, refBar, df):
    firstLowerLow = None
    firstbarL = None
    for i in range(1, lookback_in + 1):
        checkBar = refBar - i
        if checkBar >= 0 and checkBar < len(df):
            histLow = df.loc[checkBar, 'low']
            if histLow < currentLow:
                firstLowerLow = histLow
                firstbarL = checkBar
                break
    return [firstLowerLow, firstbarL]
# Modified functions
def f_drawStructBox(df, current_row, previous_row):
    if len(structArr) > 5:
        prevS = structArr[-2]
        currS = structArr[-1]
        prevBar = structBarArr[-2]
        currBar = structBarArr[-1]
        prevPr = structPriceArr[-2]
        currPr = structPriceArr[-1]
        prevpr2 = structPriceArr[-3]
        currBar2 = structBarArr[-3]
        prevS2 = structArr[-3]
        prevS3 = structArr[-4]
        prevpr3 = structPriceArr[-4]
        prevpr4 = structPriceArr[-5]
        if currBar < len(df):
            f_checkMajorOrMinor(prevS, prevS2, currS, prevBar, currBar, prevPr, currPr, prevpr2, currBar2, df, current_row, previous_row)
            f_zoneChocDown(prevS, prevS2, currS, prevBar, currBar, prevPr, currPr, prevpr2, currBar2, prevpr3, prevS3, prevpr4, df, current_row, previous_row)
            f_zoneChocUp(prevS, prevS2, currS, prevBar, currBar, prevPr, currPr, prevpr2, currBar2, prevpr3, prevS3, prevpr4, df, current_row, previous_row)
        else:
            logger.error(f"Invalid curBar index: {currBar}")
        structArr.pop(0)
        structTimeArr.pop(0)
        structPriceArr.pop(0)
        structBarArr.pop(0)

def BoS_ChoCh(B_C: bool, UpDn: bool, current_time, current_close):
    global lastHH, lastH, lastLL, lastL, lastHH_time, lastH_time, lastLL_time, lastL_time
    if B_C and UpDn:
        event_price = lastHH
        event_time = lastHH_time
        event_text = "BoS Up"
    elif (not B_C) and UpDn:
        event_price = lastH
        event_time = lastH_time
        event_text = "ChoCh Up"
    elif (not B_C) and (not UpDn):
        event_price = lastL
        event_time = lastL_time
        event_text = "ChoCh Down"
    else:
        event_price = lastLL
        event_time = lastLL_time
        event_text = "BoS Down"
    if showBC:
        logger.info(f"{event_text} at time {event_time} -> signaled at {current_time}, price = {event_price}, close = {current_close}")

def sweep(swHL: bool, swHrLr: bool, current_time):
    global lastHH, lastH, lastLL, lastL, lastHH_time, lastH_time, lastLL_time, lastL_time
    if not showSw:
        return
    if swHL and swHrLr:
        event_price = lastHH
        event_label = "HH"
        event_time = lastHH_time
    elif swHL and (not swHrLr):
        event_price = lastH
        event_label = "LH"
        event_time = lastH_time
    elif (not swHL) and swHrLr:
        event_price = lastL
        event_label = "HL"
        event_time = lastL_time
    else:
        event_price = lastLL
        event_label = "LL"
        event_time = lastLL_time
    if markX:
        logger.debug(f"Sweep event: {event_label}, from time {event_time} to time {current_time}, price {event_price}.")

def IDM(BS: bool, current_time):
    global idmB, idmS, idmB_time, idmS_time
    if not showIDM:
        return
    if BS:
        logger.info(f"IDM (Bullish) at time {idmB_time} -> signaled at {current_time}, price {idmB}.")
    else:
        logger.info(f"IDM (Bearish) at time {idmS_time} -> signaled at {current_time}, price {idmS}.")

def mnMark(UD: bool, current_time):
    global puUp, puDn, puUp_time, puDn_time
    if not showMn:
        return
    if UD:
        logger.debug(f"Minor Up Pivot at {puUp_time}, price {puUp}, triggered at {current_time}.")
    else:
        logger.debug(f"Minor Down Pivot at {puDn_time}, price {puDn}, triggered at {current_time}.")
def cfHL(isHigh: bool, current_time, current_high, current_low, current_close, bar_index, current_row, previous_row):
    global H, L, H_time, L_time, lastHH, lastLL, lastHH_time, lastLL_time
    global structArr, structTimeArr, structPriceArr, structBarArr
    if isHigh:
        actual_high = current_high if (current_high > H) else H
        label_txt = "HH" if H == lastHH else "LH"
        if showHL:
            logger.debug(f"Detected {label_txt} at time {current_time}, price {actual_high}.")
        structArr.append(label_txt)
        structTimeArr.append(current_time)
        structPriceArr.append(actual_high)
        structBarArr.append(bar_index)
        f_drawStructBox(df, current_row, previous_row)
    else:
        actual_low = current_low if (current_low < L) else L
        label_txt = "LL" if L == lastLL else "HL"
        if showHL:
            logger.debug(f"Detected {label_txt} at time {current_time}, price {actual_low}.")
        structArr.append(label_txt)
        structTimeArr.append(current_time)
        structPriceArr.append(actual_low)
        structBarArr.append(bar_index)
        f_drawStructBox(df, current_row, previous_row)
# State dictionary to replace global variables
def f_checkMajorOrMinor(prevS, prevS2, curS, prevBar, curBar, prevPr, curPr, prevpr2, currBar2, df, current_row, previous_row):
    """
    ฟังก์ชันนี้ใช้ตรวจสอบว่าโครงสร้างตลาด (structure) ที่เพิ่งเกิดขึ้นเป็น Major หรือ Minor 
    ผ่านเงื่อนไขต่าง ๆ (Ret, Choch, ฯลฯ) และบันทึก OB (Order Block) เมื่อเป็น Major
    พร้อมเพิ่ม Log เพื่อตรวจสอบลำดับเหตุการณ์ที่เกิดขึ้น รวมถึงแสดง timestamp ของ bar ปัจจุบัน
    """
    # เวลา bar ปัจจุบัน สำหรับการ Log
    current_time = current_row['timestamp'] if (current_row is not None and 'timestamp' in current_row) else "No_timestamp"

    # Log สำหรับเริ่มต้นการทำงานของฟังก์ชัน
    f_loginfo(f"[f_checkMajorOrMinor] START -> curBar={curBar}, prevS={prevS}, curS={curS}, time={current_time}")

    zoneRetUp = (prevS == "HL" and curS == "HH")       # สถานการณ์ Ret Up
    zoneRetDown = (prevS == "LH" and curS == "LL")     # สถานการณ์ Ret Down
    zonechocdn = (prevS == "HH" and curS == "LL")      # สถานการณ์ Choch Down
    zonechocup = (prevS == "LL" and curS == "HH")      # สถานการณ์ Choch Up

    # ตัวแปรช่วยสำหรับควบคุม state
    up = None
    lll = None
    dn = None
    hhh = None
    con1 = False
    con2 = False
    isMajor = False
    count = 0
    countu = 0
    chk_l = False
    chk_h = False
    waitingForHL = False
    waitingForLH = False

    # หากเป็น Choch ขึ้นลง ให้ reset ค่าเงื่อนไข
    if zonechocdn or zonechocup:
        f_loginfo(f"[f_checkMajorOrMinor] Detected zonechoc (LL->HH หรือ HH->LL) at time={current_time}")
        con1 = False
        con2 = False
        waitingForHL = False
        waitingForLH = False

    # --------------------------------------------------------------------------------------------------
    # 1) ZoneRet Up: (HL -> HH) แล้วตรวจสอบว่าการกลับตัว (Retracement) นั้นแรงพอจะเป็น Major ไหม
    # --------------------------------------------------------------------------------------------------
    if zoneRetUp and not isMajor:
        f_loginfo(f"[f_checkMajorOrMinor] ZoneRetUp Condition => prevS={prevS}, curS={curS}, time={current_time}")
        halfLine = f_get50PctLine(prevPr, curPr)
        if current_row is not None and previous_row is not None:
            low_now = current_row['low']
            low_prev = previous_row['low']
            open_now = current_row['open']
            open_prev = previous_row['open']
            close_now = current_row['close']
            close_prev = previous_row['close']

            # ตรงนี้เป็น logic สำหรับเช็ค high/low เทียบกับ halfLine ว่าต่ำกว่าหรือสูงกว่า
            if low_now < halfLine and low_prev > halfLine and not chk_l:
                chk_l = True
                lll = low_now
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] rethigh > halfLine={halfLine}, lll={lll}, time={current_time}")

            if lll is not None and low_now < lll:
                lll = low_now
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] found lower low => lll={lll}, time={current_time}")

            if lll is not None :
                if close_now < lll and close_now < halfLine:
                    up = "waiting candle2"
                    countu += 1
                    f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] waiting ret up => countu={countu}, halfLine={halfLine}, time={current_time}")

            if countu >= 1:
                # Logic ตัวอย่างสมมุติว่าเช็ค engulf
                if (close_prev < open_prev) and (close_now > open_now) \
                   and (open_now <= close_prev) and (close_now >= open_prev):
                    countu -= 1
                    f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] engulf ret up => countu={countu}, time={current_time}")

            # ถ้า countu ถึงเงื่อนไขตามต้องการ
            if countu >= 2:
                con1 = True
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] con1 = True => countu={countu}, time={current_time}")

            if con1:
                # รีเซ็ตไม่ให้เช็คซ้ำ
                chk_l = False

            # อีกเงื่อนไขคือราคา low ปัจจุบันต้องต่ำกว่า prevpr2 ด้วย
            if prevpr2 is not None and low_now < prevpr2:
                con2 = True

            f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] con1={con1}, con2={con2}, curClose={close_now}, time={current_time}")

            # เป็น Major ได้ก็ต่อเมื่อ con1 และ con2 เป็นจริง
            isMajor = con1 and con2
            if isMajor:
                waitingForHL = True
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] -> isMajor=True, waitingForHL=True, time={current_time}")
        else:
            logger.warning("[f_checkMajorOrMinor|ZoneRetUp] Missing current or previous row data")

    # หากเกิดการรอ HL (waitingForHL) เมื่อไหร่ก็ตามที่เจอ HL
    if waitingForHL and curS == "HL":
        f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] waitingForHL & found HL => curS={curS}, time={current_time}")
        waitingForHL = False
        isMajor = False  # ดึงกลับมา set ไว้ก่อน
        currentHigh = current_row['high'] if current_row is not None else None
        if currentHigh is not None:
            [firstHigherHigh, firstbarH] = f_findFirstHigherHigh(currentHigh, lookback, curBar, df)
            if not is_na(firstHigherHigh) and not is_na(firstbarH):
                # บันทึกเป็น OB
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] Found Higher High => {firstHigherHigh} at bar={firstbarH}, time={current_time}")
                topOB = firstHigherHigh
                bottomOB = curPr
                f_storeOB(True, topOB, bottomOB, current_time)
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] Confirmed Major with HL => curS={curS}, time={current_time}")

    # ถ้าเกิดเจอ LL ระหว่างที่กำลังรอ HL => โมเมนตัมขึ้นอาจเสีย
    if isMajor and curS == "LL":
        f_loginfo(f"[f_checkMajorOrMinor|ZoneRetUp] Major invalidated => found LL while waiting HL, time={current_time}")
        isMajor = False
        waitingForHL = False

    # ถ้าไม่ใช่ ZoneRetUp เคสอื่นก็รีเซ็ต
    if not zoneRetUp:
        countu = 0
        isMajor = False
        con1 = False
        con2 = False

    # --------------------------------------------------------------------------------------------------
    # 2) ZoneRet Down: (LH -> LL) แล้วตรวจสอบเงื่อนไขสำหรับการเป็น Major
    # --------------------------------------------------------------------------------------------------
    if zoneRetDown and not isMajor:
        f_loginfo(f"[f_checkMajorOrMinor] ZoneRetDown Condition => prevS={prevS}, curS={curS}, time={current_time}")
        halfLine = f_get50PctLine(prevPr, curPr)
        if current_row is not None and previous_row is not None:
            high_now = current_row['high']
            high_prev = previous_row['high']
            open_now = current_row['open']
            open_prev = previous_row['open']
            close_now = current_row['close']
            close_prev = previous_row['close']

            if high_now > halfLine and high_prev < halfLine and not chk_h:
                chk_h = True
                hhh = high_now
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] retdn < halfLine={halfLine}, hhh={hhh}, time={current_time}")

            if hhh is not None and high_now > hhh:
                hhh = high_now
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] found higher high => hhh={hhh}, time={current_time}")

            if  hhh is not None:
                if close_now > hhh and close_now > halfLine:
                    dn = "waiting candle2"
                    count += 1
                    f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] waiting ret down => count={count}, halfLine={halfLine}, time={current_time}")

            if count > 0:
                if (close_prev > open_prev) and (close_now < open_now) \
                   and (open_now >= close_prev) and (close_now <= open_prev):
                    count -= 1
                    f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] engulf => count={count}, time={current_time}")

            if count >= 2:
                con1 = True
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] con1=True => count={count}, time={current_time}")

            if con1:
                chk_h = False

            if high_now > prevpr2:
                con2 = True

            f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] con1={con1}, con2={con2}, close={close_now}, time={current_time}")

            isMajor = con1 and con2
            if isMajor:
                waitingForLH = True
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] -> isMajor=True, waitingForLH=True, time={current_time}")
        else:
            logger.warning("[f_checkMajorOrMinor|ZoneRetDown] Missing current or previous row data")

    if waitingForLH and curS == "LL" and prevS == "LL":
        f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] waitingForLH & found (LL->LL) => reset Major, time={current_time}")
        isMajor = False
        waitingForLH = False
        con1 = False
        con2 = False

    if waitingForLH and curS == "LH":
        f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] waitingForLH & found LH => time={current_time}")
        waitingForLH = False
        isMajor = False  # กันเผื่อเหตุการณ์ invalid
        currentLow = current_row['low'] if current_row is not None else None
        if currentLow is not None:
            [firstLowerLow, firstbarL] = f_findFirstLowerLow(currentLow, lookback, curBar, df)
            if not is_na(firstLowerLow) and not is_na(firstbarL):
                f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] Found Lower Low => {firstLowerLow} at bar={firstbarL}, time={current_time}")
                bottomOB = firstLowerLow
                topOB = curPr
                f_storeOB(False, topOB, bottomOB, current_time)
            # หาก firstbarL == curBar ก็แปลว่าตรงกับแท่งปัจจุบัน
            if not is_na(firstbarL) and firstbarL == curBar:
                bottomOB = firstLowerLow
                topOB = curPr
                f_storeOB(False, topOB, bottomOB, current_time)
            f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] Confirmed Major with LH => curS={curS}, time={current_time}")

    if isMajor and curS == "HH":
        f_loginfo(f"[f_checkMajorOrMinor|ZoneRetDown] Major invalidated => found HH while waiting LH, time={current_time}")
        isMajor = False
        waitingForLH = False

    # ถ้าไม่ใช่ ZoneRetDown
    if not zoneRetDown:
        count = 0
        isMajor = False
        con1 = False
        con2 = False

    # สุดท้าย return ว่าอันนี้เป็น Major หรือไม่
    f_loginfo(f"[f_checkMajorOrMinor] END -> isMajor={isMajor}, time={current_time}")
    return isMajor




def f_zoneChocUp(prevS, prevS2, curS, prevBar, curBar, prevPr, curPr, prevpr2, currBar2, 
                 prevpr3, prevS3, prevpr4, df, current_row, previous_row):
    # ประกาศตัวแปรเริ่มต้น
    isMajor = False
    con1 = False
    con2 = False
    count = 0
    chk_l = False
    lll = None
    up = None
    waitingForHL = False
    pre = 0

    # ดึงค่า current_time จาก current_row
    current_time = current_row['timestamp'] if current_row is not None else None

    # Log จุดเริ่มต้นของฟังก์ชัน
    logger.info(f"[f_zoneChocUp] => START at time {current_time} | prevS={prevS}, curS={curS}, prevPr={prevPr}, curPr={curPr}")

    zoneChocUp = (prevS == "LL" and curS == "HH")
    logger.debug(f"[f_zoneChocUp] Check zoneChocUp => {zoneChocUp}")

    if zoneChocUp and not isMajor:
        halfLine = f_get50PctLine(prevPr, curPr)
        logger.debug(f"[f_zoneChocUp] halfLine calculated => {halfLine}")

        # ตรวจสอบว่า current_row และ previous_row มีข้อมูลหรือไม่
        if current_row is not None and previous_row is not None:
            low_now = current_row['low']
            low_prev = previous_row['low']
            open_now = current_row['open']
            open_prev = previous_row['open']
            close_now = current_row['close']
            close_prev = previous_row['close']

            logger.debug(f"[f_zoneChocUp] low_now={low_now}, low_prev={low_prev}, close_now={close_now}, close_prev={close_prev}")

            # เงื่อนไขตรวจสอบส่วนต่าง ๆ
            if low_now < halfLine and low_prev > halfLine and not chk_l:
                chk_l = True
                lll = low_now
                logger.info(f"[f_zoneChocUp] => Condition triggered: low_now < halfLine < low_prev | lll={lll}")

            if lll is not None and low_now < lll:
                lll = low_now
                logger.info(f"[f_zoneChocUp] => Update lll => {lll}")

            if lll is not None :
                if close_now < lll and close_now < halfLine:
                    up = "waiting candle2"
                    count += 1
                    logger.info(f"[f_zoneChocUp] => waiting candle2 triggered | count={count}")

            if count >= 1:
                # ตรวจสอบรูปแบบ engulf
                if (close_prev < open_prev) and (close_now > open_now) \
                   and (open_now <= close_prev) and (close_now >= open_prev):
                    count -= 1
                    logger.info(f"[f_zoneChocUp] => Engulf pattern triggered, decrement count => {count}")

            if count >= 2:
                logger.info(f"[f_zoneChocUp] => con1 becomes True (count >= 2)")
                con1 = True

            # เอา prevpr3 กับ prevpr4 มาดูเทียบ
            pre = prevpr3
            if prevpr3 < prevpr4:
                pre = prevpr4

            if low_now < pre:
                con2 = True
                logger.info(f"[f_zoneChocUp] => con2 becomes True (low_now < pre) | pre={pre}")

            logger.debug(f"[f_zoneChocUp] con1={con1}, con2={con2}, count={count}, chk_l={chk_l}")

            isMajor = con1 and con2
            if isMajor:
                waitingForHL = True
                con1 = False
                con2 = False
                count = 0
                halfLine = None
                logger.info(f"[f_zoneChocUp] => Detected MAJOR ChocUp, set waitingForHL=True")
        else:
            logger.warning("[f_zoneChocUp] => Missing current or previous row data")

    # กรณีรอ HL เพื่อตรวจสอบยืนยัน Major
    if waitingForHL and curS == "HL":
        # เมื่อเกิด HL แล้ว จะทำการยกเลิกการรอ
        isMajor = False
        waitingForHL = False
        count = 0
        logger.info(f"[f_zoneChocUp] => waitingForHL met HL => cancel waiting, check for Higher High")

        if current_row is not None:
            currentHigh = current_row['high']
            [firstHigherHigh, firstbarH] = f_findFirstHigherHigh(currentHigh, lookback, curBar, df)
            if not is_na(firstHigherHigh) and not is_na(firstbarH):
                logger.info(f"[f_zoneChocUp] => Found Higher High={firstHigherHigh} at bar={firstbarH}")
                topOB = firstHigherHigh
                bottomOB = curPr
                f_storeOB(True, topOB, bottomOB, current_time)
                logger.info(f"[f_zoneChocUp] => Confirmed Major ChocUp with HL => {curBar}")
        else:
            logger.warning("[f_zoneChocUp] => current_row is None while waitingForHL")

    # ถ้ายังรอ HL อยู่แต่ดันได้ HH ต่อกัน หรือเจอเงื่อนไขอื่น ๆ
    if waitingForHL and curS == "HH" and prevS == "HH":
        isMajor = False
        waitingForHL = False
        con1 = False
        con2 = False
        count = 0
        logger.info("[f_zoneChocUp] => waitingForHL but got HH again => reset everything")

    # ถ้าเป็น Major อยู่แต่โดน LL => invalidated
    if isMajor and curS == "LL":
        isMajor = False
        waitingForHL = False
        logger.info(f"[f_zoneChocUp] => Major ChocUp invalidated due to LL => {curS}")

    # ถ้าไม่ได้เป็น zoneChocUp => reset
    if not zoneChocUp:
        count = 0
        isMajor = False
        con1 = False
        con2 = False

    logger.debug(f"[f_zoneChocUp] => END at time {current_time}, isMajor={isMajor}, waitingForHL={waitingForHL}")
    return isMajor

def f_zoneChocDown(prevS, prevS2, curS, prevBar, curBar, prevPr, curPr, prevpr2, currBar2, 
                   prevpr3, prevS3, prevpr4, df, current_row, previous_row):
    # ประกาศตัวแปรเริ่มต้น
    isMajor = False
    con1 = False
    con2 = False
    count = 0
    chk_h = False
    hhh = None
    dn = None
    waitingForLH = False
    pre = 0

    # ดึงค่า current_time จาก current_row
    current_time = current_row['timestamp'] if current_row is not None else None

    # Log จุดเริ่มต้นของฟังก์ชัน
    logger.info(f"[f_zoneChocDown] => START at time {current_time} | prevS={prevS}, curS={curS}, prevPr={prevPr}, curPr={curPr}")

    zoneChocDown = (prevS == "HH" and curS == "LL")
    logger.debug(f"[f_zoneChocDown] Check zoneChocDown => {zoneChocDown}")

    if zoneChocDown and not isMajor:
        halfLine = f_get50PctLine(prevPr, curPr)
        logger.debug(f"[f_zoneChocDown] halfLine calculated => {halfLine}")

        if current_row is not None and previous_row is not None:
            high_now = current_row['high']
            high_prev = previous_row['high']
            open_now = current_row['open']
            open_prev = previous_row['open']
            close_now = current_row['close']
            close_prev = previous_row['close']

            logger.debug(f"[f_zoneChocDown] high_now={high_now}, high_prev={high_prev}, close_now={close_now}, close_prev={close_prev}")

            if high_now > halfLine and high_prev < halfLine and not chk_h:
                chk_h = True
                hhh = high_now
                logger.info(f"[f_zoneChocDown] => Condition triggered: high_now > halfLine > high_prev | hhh={hhh}")

            if hhh is not None and high_now > hhh:
                hhh = high_now
                logger.info(f"[f_zoneChocDown] => Update hhh => {hhh}")

            if hhh is not None:
                if close_now > hhh and close_now > halfLine:
                    dn = "waiting candle2"
                    count += 1
                    logger.info(f"[f_zoneChocDown] => waiting candle2 triggered | count={count}")

            # ตรวจสอบ engulf pattern (ตัวอย่างเงื่อนไขแบบเดียวกับในโค้ด)
            if count > 0 and close_prev > hhh and close_now < hhh:
                if (close_prev > open_prev) and (close_now < open_now) \
                   and (open_now >= close_prev) and (close_now <= open_prev):
                    count -= 1
                    logger.info(f"[f_zoneChocDown] => Engulf pattern triggered, decrement count => {count}")

            if count >= 2:
                logger.info(f"[f_zoneChocDown] => con1 becomes True (count >= 2)")
                count = 0
                con1 = True

            if con1:
                chk_h = False

            pre = prevpr3
            if prevpr3 > prevpr4:
                pre = prevpr4

            if high_now > prevpr3:
                con2 = True
                logger.info("[f_zoneChocDown] => con2 becomes True (high_now > prevpr3)")

            logger.debug(f"[f_zoneChocDown] con1={con1}, con2={con2}, count={count}, chk_h={chk_h}")

            isMajor = con1 and con2
            if isMajor:
                waitingForLH = True
                con1 = False
                con2 = False
                count = 0
                halfLine = None
                logger.info("[f_zoneChocDown] => Detected MAJOR ChocDown, set waitingForLH=True")
        else:
            logger.warning("[f_zoneChocDown] => Missing current or previous row data")

    # รอ LH เพื่อ confirm ว่าเป็น Major
    if waitingForLH and curS == "LH":
        isMajor = False
        waitingForLH = False
        count = 0
        logger.info("[f_zoneChocDown] => waitingForLH met LH => check for Lower Low")

        if current_row is not None:
            currentLow = current_row['low']
            [firstLowerLow, firstbarL] = f_findFirstLowerLow(currentLow, lookback, curBar, df)
            if not is_na(firstLowerLow) and not is_na(firstbarL):
                bottomOB = firstLowerLow
                topOB = curPr
                f_storeOB(False, topOB, bottomOB, current_time)
                logger.info(f"[f_zoneChocDown] => Confirmed Major ChocDown with LH => {curS}")
                
                if firstbarL == curBar:
                    logger.info("[f_zoneChocDown] => firstbarL == curBar => storeOB again if needed")
                    f_storeOB(False, topOB, bottomOB, current_time)
        else:
            logger.warning("[f_zoneChocDown] => current_row is None while waitingForLH")

    # ถ้ายังรอ LH อยู่แต่เจอ LL ต่อเนื่อง หรือเงื่อนไขอื่น ๆ
    if waitingForLH and curS == "LL" and prevS == "LL":
        isMajor = False
        waitingForLH = False
        con1 = False
        con2 = False
        logger.info("[f_zoneChocDown] => waitingForLH but got LL => reset everything")

    # ถ้าเป็น Major อยู่แต่โดน HH => invalidated
    if isMajor and curS == "HH":
        isMajor = False
        waitingForLH = False
        logger.info(f"[f_zoneChocDown] => Major ChocDown invalidated due to HH => {curS}")

    # ถ้าไม่ใช่ zoneChocDown => reset
    if not zoneChocDown:
        count = 0
        isMajor = False
        con1 = False
        con2 = False

    logger.debug(f"[f_zoneChocDown] => END at time {current_time}, isMajor={isMajor}, waitingForLH={waitingForLH}")
    return isMajor



def main():
    global df, mnUp, mnDn, top, bot, puUp, puDn, L, H, idmB, idmS, lastH, lastL, lastHH, lastLL
    global puUp_time, puDn_time, idmB_time, idmS_time, H_time, L_time, lastH_time, lastL_time, lastHH_time, lastLL_time
    global isBosUp, isBosDn, isCocUp, isCocDn
    try:
        df = load_ohlcv("15m.csv")
        if len(df) == 0:
            logger.error("Empty DataFrame loaded")
            return
        first_row = df.iloc[0]
        top = first_row['high']
        bot = first_row['low']
        puUp = first_row['high']
        puDn = first_row['low']
        H = first_row['high']
        L = first_row['low']
        idmB = first_row['low']
        idmS = first_row['high']
        lastH = first_row['high']
        lastL = first_row['low']
        lastHH = first_row['high']
        lastLL = first_row['low']
        t = first_row['timestamp']
        puUp_time = t
        puDn_time = t
        H_time = t
        L_time = t
        idmB_time = t
        idmS_time = t
        lastH_time = t
        lastL_time = t
        lastHH_time = t
        lastLL_time = t
        mnUp = False
        mnDn = False

        for i in range(len(df)):
            row = df.iloc[i]
            current_time = row['timestamp']
            current_high = row['high']
            current_low = row['low']
            current_close = row['close']
            previous_row = df.iloc[i-1] if i >= 1 else None
            previous2_row = df.iloc[i-2] if i >= 2 else None

            if ((current_high > H) or (equalHL and abs(current_high - H) < 1e-12)) and (current_low > idmB):
                if current_low <= puDn:
                    idmB = current_low
                    idmB_time = current_time
                else:
                    idmB = puDn
                    idmB_time = puDn_time

            if ((current_low < L) or (equalHL and abs(current_low - L) < 1e-12)) and (current_high < idmS):
                if current_high >= puUp:
                    idmS = current_high
                    idmS_time = current_time
                else:
                    idmS = puUp
                    idmS_time = puUp_time

            if isCocUp:
                if current_low < idmB:
                    if abs(idmB - lastL) > 1e-12:
                        IDM(True, current_time)
                    isBosUp = False
                    lastH = H
                    lastH_time = H_time
                    lastHH = H
                    lastHH_time = H_time
                    cfHL(True, current_time, current_high, current_low, current_close, i, row, previous_row)
                    L = current_low
                    L_time = current_time
            elif (abs(lastH - lastHH) > 1e-12) and (current_high > lastH):
                cfHL(False, current_time, current_high, current_low, current_close, i, row, previous_row)
                isCocDn = False
                isBosDn = False
                if current_close > lastH:
                    BoS_ChoCh(False, True, current_time, current_close)
                    isCocUp = True
                else:
                    sweep(True, False, current_time)

            if isCocDn:
                if current_high > idmS:
                    if abs(idmS - lastH) > 1e-12:
                        IDM(False, current_time)
                    isBosDn = False
                    lastL = L
                    lastL_time = L_time
                    lastLL = L
                    lastLL_time = L_time
                    cfHL(False, current_time, current_high, current_low, current_close, i, row, previous_row)
                    H = current_high
                    H_time = current_time
            elif (current_low < lastL) and (abs(lastL - lastLL) > 1e-12):
                if current_close < lastL:
                    BoS_ChoCh(False, False, current_time, current_close)
                    cfHL(True, current_time, current_high, current_low, current_close, i, row, previous_row)
                    isCocDn = True
                    isCocUp = False
                    isBosUp = False
                else:
                    sweep(False, True, current_time)

            if not isBosUp:
                if current_high > lastHH:
                    if current_close > lastHH:
                        BoS_ChoCh(True, True, current_time, current_close)
                        cfHL(False, current_time, current_high, current_low, current_close, i, row, previous_row)
                        lastL = L
                        lastL_time = L_time
                        isCocUp = True
                        isBosUp = True
                        isCocDn = False
                        isBosDn = False
                    else:
                        sweep(True, True, current_time)

            if not isBosDn:
                if current_low < lastLL:
                    if current_close < lastLL:
                        BoS_ChoCh(True, False, current_time, current_close)
                        cfHL(True, current_time, current_high, current_low, current_close, i, row, previous_row)
                        lastH = H
                        lastH_time = H_time
                        isCocUp = False
                        isBosUp = False
                        isCocDn = True
                        isBosDn = True
                    else:
                        sweep(False, False, current_time)

            if equalHL:
                if current_high >= top:
                    if current_low > bot:
                        mnDn = False
                    mnUp = True
                if current_low <= bot:
                    if current_high < top:
                        mnUp = False
                    mnDn = True
            else:
                if current_high > top:
                    if current_low > bot:
                        mnDn = False
                    mnUp = True
                if current_low < bot:
                    if current_high < top:
                        mnUp = False
                    mnDn = True

            old_top = top
            old_bot = bot

            if equalHL:
                if current_high >= top:
                    puUp = current_high
                    puUp_time = current_time
                if current_low <= bot:
                    puDn = current_low
                    puDn_time = current_time
                    top = current_high
                    bot = current_low
                if current_high >= top:
                    top = current_high
                    bot = current_low
            else:
                if current_high > top:
                    puUp = current_high
                    puUp_time = current_time
                if current_low < bot:
                    puDn = current_low
                    puDn_time = current_time
                    top = current_high
                    bot = current_low
                if current_high > top:
                    top = current_high
                    bot = current_low

            if (current_high > H) or (equalHL and abs(current_high - H) < 1e-12):
                H = current_high
                H_time = current_time
            if current_high > idmS:
                idmS = current_high
                idmS_time = current_time
            if (current_high > lastH) or (equalHL and abs(current_high - lastH) < 1e-12):
                lastH = current_high
                lastH_time = current_time
            if (current_high > lastHH) or (equalHL and abs(current_high - lastHH) < 1e-12):
                lastHH = current_high
                lastHH_time = current_time

            if (current_low < L) or (equalHL and abs(current_low - L) < 1e-12):
                L = current_low
                L_time = current_time
            if current_low < idmB:
                idmB = current_low
                idmB_time = current_time
            if (current_low < lastL) or (equalHL and abs(current_low - lastL) < 1e-12):
                lastL = current_low
                lastL_time = current_time
            if (current_low < lastLL) or (equalHL and abs(current_low - lastLL) < 1e-12):
                lastLL = current_low
                lastLL_time = current_time

        f_loginfo(f"Structure detection logic completed. structArr size: {len(structArr)}")
        f_loginfo(f"OB Array size: {len(obArray)}")
        for idx, ob in enumerate(obArray):
            f_loginfo(f"OB #{idx} => Time: {ob.bar_time}, Top: {ob.topPrice}, Bottom: {ob.bottomPrice}, MajorUp: {ob.isMajorUp}")
    except Exception as e:
        logger.error(f"Error in main: {e}")

if __name__ == "__main__":
    main()

